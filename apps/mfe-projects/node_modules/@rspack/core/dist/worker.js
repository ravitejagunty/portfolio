"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/lib/WebpackError.ts
var import_node_util, WebpackError, WebpackError_default;
var init_WebpackError = __esm({
  "src/lib/WebpackError.ts"() {
    "use strict";
    import_node_util = require("util");
    WebpackError = class extends Error {
      [import_node_util.inspect.custom]() {
        return this.stack + (this.details ? `
${this.details}` : "");
      }
    };
    WebpackError_default = WebpackError;
  }
});

// src/lib/AbstractMethodError.ts
function createMessage(method) {
  return `Abstract method${method ? ` ${method}` : ""}. Must be overridden.`;
}
var CURRENT_METHOD_REGEXP, Message, AbstractMethodError, AbstractMethodError_default;
var init_AbstractMethodError = __esm({
  "src/lib/AbstractMethodError.ts"() {
    "use strict";
    init_WebpackError();
    CURRENT_METHOD_REGEXP = /at ([a-zA-Z0-9_.]*)/;
    Message = class extends Error {
      constructor() {
        super();
        this.stack = void 0;
        Error.captureStackTrace(this);
        const match = this.stack.split("\n")[3].match(CURRENT_METHOD_REGEXP);
        this.message = (match == null ? void 0 : match[1]) ? createMessage(match[1]) : createMessage();
      }
    };
    AbstractMethodError = class extends WebpackError_default {
      constructor() {
        super(new Message().message);
        this.name = "AbstractMethodError";
      }
    };
    AbstractMethodError_default = AbstractMethodError;
  }
});

// src/util/hash/index.ts
var Hash;
var init_hash = __esm({
  "src/util/hash/index.ts"() {
    "use strict";
    init_AbstractMethodError();
    Hash = class {
      /* istanbul ignore next */
      /**
       * Update hash {@link https://nodejs.org/api/crypto.html#crypto_hash_update_data_inputencoding}
       * @abstract
       * @param data data
       * @param inputEncoding data encoding
       * @returns updated hash
       */
      update(data, inputEncoding) {
        throw new AbstractMethodError_default();
      }
      /* istanbul ignore next */
      /**
       * Calculates the digest {@link https://nodejs.org/api/crypto.html#crypto_hash_digest_encoding}
       * @abstract
       * @param encoding encoding of the return value
       * @returns  digest
       */
      digest(encoding) {
        throw new AbstractMethodError_default();
      }
    };
  }
});

// src/util/hash/wasm-hash.ts
var MAX_SHORT_STRING, WasmHash, create, wasm_hash_default;
var init_wasm_hash = __esm({
  "src/util/hash/wasm-hash.ts"() {
    "use strict";
    MAX_SHORT_STRING = Math.floor((65536 - 64) / 4) & ~3;
    WasmHash = class {
      /**
       * @param instance wasm instance
       * @param instancesPool pool of instances
       * @param chunkSize size of data chunks passed to wasm
       * @param digestSize size of digest returned by wasm
       */
      constructor(instance, instancesPool, chunkSize, digestSize) {
        const exports2 = instance.exports;
        exports2.init();
        this.exports = exports2;
        this.mem = Buffer.from(exports2.memory.buffer, 0, 65536);
        this.buffered = 0;
        this.instancesPool = instancesPool;
        this.chunkSize = chunkSize;
        this.digestSize = digestSize;
      }
      reset() {
        this.buffered = 0;
        this.exports.init();
      }
      /**
       * @param data data
       * @param encoding encoding
       * @returns itself
       */
      update(data, encoding) {
        if (typeof data === "string") {
          let normalizedData = data;
          while (normalizedData.length > MAX_SHORT_STRING) {
            this._updateWithShortString(
              normalizedData.slice(0, MAX_SHORT_STRING),
              encoding
            );
            normalizedData = normalizedData.slice(MAX_SHORT_STRING);
          }
          this._updateWithShortString(normalizedData, encoding);
          return this;
        }
        this._updateWithBuffer(data);
        return this;
      }
      /**
       * @param {string} data data
       * @param {BufferEncoding=} encoding encoding
       * @returns {void}
       */
      _updateWithShortString(data, encoding) {
        const { exports: exports2, buffered, mem, chunkSize } = this;
        let endPos;
        if (data.length < 70) {
          if (!encoding || encoding === "utf-8" || encoding === "utf8") {
            endPos = buffered;
            for (let i = 0; i < data.length; i++) {
              const cc = data.charCodeAt(i);
              if (cc < 128) mem[endPos++] = cc;
              else if (cc < 2048) {
                mem[endPos] = cc >> 6 | 192;
                mem[endPos + 1] = cc & 63 | 128;
                endPos += 2;
              } else {
                endPos += mem.write(data.slice(i), endPos, encoding);
                break;
              }
            }
          } else if (encoding === "latin1") {
            endPos = buffered;
            for (let i = 0; i < data.length; i++) {
              const cc = data.charCodeAt(i);
              mem[endPos++] = cc;
            }
          } else {
            endPos = buffered + mem.write(data, buffered, encoding);
          }
        } else {
          endPos = buffered + mem.write(data, buffered, encoding);
        }
        if (endPos < chunkSize) {
          this.buffered = endPos;
        } else {
          const l = endPos & ~(this.chunkSize - 1);
          exports2.update(l);
          const newBuffered = endPos - l;
          this.buffered = newBuffered;
          if (newBuffered > 0) mem.copyWithin(0, l, endPos);
        }
      }
      /**
       * @param data data
       * @returns
       */
      _updateWithBuffer(data) {
        const { exports: exports2, buffered, mem } = this;
        const length = data.length;
        if (buffered + length < this.chunkSize) {
          data.copy(mem, buffered, 0, length);
          this.buffered += length;
        } else {
          const l = buffered + length & ~(this.chunkSize - 1);
          if (l > 65536) {
            let i = 65536 - buffered;
            data.copy(mem, buffered, 0, i);
            exports2.update(65536);
            const stop = l - buffered - 65536;
            while (i < stop) {
              data.copy(mem, 0, i, i + 65536);
              exports2.update(65536);
              i += 65536;
            }
            data.copy(mem, 0, i, l - buffered);
            exports2.update(l - buffered - i);
          } else {
            data.copy(mem, buffered, 0, l - buffered);
            exports2.update(l);
          }
          const newBuffered = length + buffered - l;
          this.buffered = newBuffered;
          if (newBuffered > 0) data.copy(mem, 0, length - newBuffered, length);
        }
      }
      digest(type) {
        const { exports: exports2, buffered, mem, digestSize } = this;
        exports2.final(buffered);
        this.instancesPool.push(this);
        const hex = mem.toString("latin1", 0, digestSize);
        if (type === "hex") return hex;
        if (type === "binary" || !type) return Buffer.from(hex, "hex");
        return Buffer.from(hex, "hex").toString(type);
      }
    };
    create = (wasmModule, instancesPool, chunkSize, digestSize) => {
      if (instancesPool.length > 0) {
        const old = instancesPool.pop();
        old.reset();
        return old;
      }
      return new WasmHash(
        new WebAssembly.Instance(wasmModule),
        instancesPool,
        chunkSize,
        digestSize
      );
    };
    wasm_hash_default = create;
  }
});

// src/util/hash/BatchedHash.ts
var BatchedHash;
var init_BatchedHash = __esm({
  "src/util/hash/BatchedHash.ts"() {
    "use strict";
    init_hash();
    init_wasm_hash();
    BatchedHash = class extends Hash {
      constructor(hash) {
        super();
        this.string = void 0;
        this.encoding = void 0;
        this.hash = hash;
      }
      /**
       * Update hash {@link https://nodejs.org/api/crypto.html#crypto_hash_update_data_inputencoding}
       * @param data data
       * @param inputEncoding data encoding
       * @returns updated hash
       */
      update(data, inputEncoding) {
        if (this.string !== void 0) {
          if (typeof data === "string" && inputEncoding === this.encoding && this.string.length + data.length < MAX_SHORT_STRING) {
            this.string += data;
            return this;
          }
          this.hash.update(this.string, this.encoding);
          this.string = void 0;
        }
        if (typeof data === "string") {
          if (data.length < MAX_SHORT_STRING && // base64 encoding is not valid since it may contain padding chars
          (!inputEncoding || !inputEncoding.startsWith("ba"))) {
            this.string = data;
            this.encoding = inputEncoding;
          } else {
            this.hash.update(data, inputEncoding);
          }
        } else {
          this.hash.update(data);
        }
        return this;
      }
      /**
       * Calculates the digest {@link https://nodejs.org/api/crypto.html#crypto_hash_digest_encoding}
       * @param encoding encoding of the return value
       * @returns digest
       */
      digest(encoding) {
        if (this.string !== void 0) {
          this.hash.update(this.string, this.encoding);
        }
        return this.hash.digest(encoding);
      }
    };
  }
});

// src/util/hash/md4.ts
var createMd4, md4_default;
var init_md4 = __esm({
  "src/util/hash/md4.ts"() {
    "use strict";
    init_wasm_hash();
    md4_default = () => {
      if (!createMd4) {
        const md4 = new WebAssembly.Module(
          Buffer.from(
            // 2156 bytes
            "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",
            "base64"
          )
        );
        createMd4 = wasm_hash_default.bind(null, md4, [], 64, 32);
      }
      return createMd4();
    };
  }
});

// src/util/hash/xxhash64.ts
var createXxhash64, xxhash64_default;
var init_xxhash64 = __esm({
  "src/util/hash/xxhash64.ts"() {
    "use strict";
    init_wasm_hash();
    xxhash64_default = () => {
      if (!createXxhash64) {
        const xxhash64 = new WebAssembly.Module(
          Buffer.from(
            // 1170 bytes
            "AGFzbQEAAAABCAJgAX8AYAAAAwQDAQAABQMBAAEGGgV+AUIAC34BQgALfgFCAAt+AUIAC34BQgALByIEBGluaXQAAAZ1cGRhdGUAAQVmaW5hbAACBm1lbW9yeQIACrIIAzAAQtbrgu7q/Yn14AAkAELP1tO+0ser2UIkAUIAJAJC+erQ0OfJoeThACQDQgAkBAvUAQIBfwR+IABFBEAPCyMEIACtfCQEIwAhAiMBIQMjAiEEIwMhBQNAIAIgASkDAELP1tO+0ser2UJ+fEIfiUKHla+vmLbem55/fiECIAMgASkDCELP1tO+0ser2UJ+fEIfiUKHla+vmLbem55/fiEDIAQgASkDEELP1tO+0ser2UJ+fEIfiUKHla+vmLbem55/fiEEIAUgASkDGELP1tO+0ser2UJ+fEIfiUKHla+vmLbem55/fiEFIAAgAUEgaiIBSw0ACyACJAAgAyQBIAQkAiAFJAMLqAYCAX8EfiMEQgBSBH4jACICQgGJIwEiA0IHiXwjAiIEQgyJfCMDIgVCEol8IAJCz9bTvtLHq9lCfkIfiUKHla+vmLbem55/foVCh5Wvr5i23puef35CnaO16oOxjYr6AH0gA0LP1tO+0ser2UJ+Qh+JQoeVr6+Ytt6bnn9+hUKHla+vmLbem55/fkKdo7Xqg7GNivoAfSAEQs/W077Sx6vZQn5CH4lCh5Wvr5i23puef36FQoeVr6+Ytt6bnn9+Qp2jteqDsY2K+gB9IAVCz9bTvtLHq9lCfkIfiUKHla+vmLbem55/foVCh5Wvr5i23puef35CnaO16oOxjYr6AH0FQsXP2bLx5brqJwsjBCAArXx8IQIDQCABQQhqIABNBEAgAiABKQMAQs/W077Sx6vZQn5CH4lCh5Wvr5i23puef36FQhuJQoeVr6+Ytt6bnn9+Qp2jteqDsY2K+gB9IQIgAUEIaiEBDAELCyABQQRqIABNBEAgAiABNQIAQoeVr6+Ytt6bnn9+hUIXiULP1tO+0ser2UJ+Qvnz3fGZ9pmrFnwhAiABQQRqIQELA0AgACABRwRAIAIgATEAAELFz9my8eW66id+hUILiUKHla+vmLbem55/fiECIAFBAWohAQwBCwtBACACIAJCIYiFQs/W077Sx6vZQn4iAkIdiCAChUL5893xmfaZqxZ+IgJCIIggAoUiAkIgiCIDQv//A4NCIIYgA0KAgPz/D4NCEIiEIgNC/4GAgPAfg0IQhiADQoD+g4CA4D+DQgiIhCIDQo+AvIDwgcAHg0IIhiADQvCBwIeAnoD4AINCBIiEIgNChoyYsODAgYMGfEIEiEKBgoSIkKDAgAGDQid+IANCsODAgYOGjJgwhHw3AwBBCCACQv////8PgyICQv//A4NCIIYgAkKAgPz/D4NCEIiEIgJC/4GAgPAfg0IQhiACQoD+g4CA4D+DQgiIhCICQo+AvIDwgcAHg0IIhiACQvCBwIeAnoD4AINCBIiEIgJChoyYsODAgYMGfEIEiEKBgoSIkKDAgAGDQid+IAJCsODAgYOGjJgwhHw3AwAL",
            "base64"
          )
        );
        createXxhash64 = wasm_hash_default.bind(null, xxhash64, [], 32, 16);
      }
      return createXxhash64();
    };
  }
});

// src/util/createHash.ts
var createHash_exports = {};
__export(createHash_exports, {
  createHash: () => createHash
});
var import_node_crypto, BULK_SIZE, digestCaches, BulkUpdateDecorator, DebugHash, createHash;
var init_createHash = __esm({
  "src/util/createHash.ts"() {
    "use strict";
    import_node_crypto = __toESM(require("crypto"));
    init_hash();
    init_BatchedHash();
    init_md4();
    init_xxhash64();
    BULK_SIZE = 2e3;
    digestCaches = {};
    BulkUpdateDecorator = class extends Hash {
      /**
       * @param hashOrFactory function to create a hash
       * @param hashKey key for caching
       */
      constructor(hashOrFactory, hashKey) {
        super();
        this.hashKey = hashKey;
        if (typeof hashOrFactory === "function") {
          this.hashFactory = hashOrFactory;
          this.hash = void 0;
        } else {
          this.hashFactory = void 0;
          this.hash = hashOrFactory;
        }
        this.buffer = "";
      }
      /**
       * Update hash {@link https://nodejs.org/api/crypto.html#crypto_hash_update_data_inputencoding}
       * @param data data
       * @param inputEncoding data encoding
       * @returns updated hash
       */
      update(data, inputEncoding) {
        if (inputEncoding !== void 0 || typeof data !== "string" || data.length > BULK_SIZE) {
          if (this.hash === void 0) this.hash = this.hashFactory();
          if (this.buffer.length > 0) {
            this.hash.update(this.buffer);
            this.buffer = "";
          }
          this.hash.update(data, inputEncoding);
        } else {
          this.buffer += data;
          if (this.buffer.length > BULK_SIZE) {
            if (this.hash === void 0) this.hash = this.hashFactory();
            this.hash.update(this.buffer);
            this.buffer = "";
          }
        }
        return this;
      }
      /**
       * Calculates the digest {@link https://nodejs.org/api/crypto.html#crypto_hash_digest_encoding}
       * @param encoding encoding of the return value
       * @returns digest
       */
      digest(encoding) {
        let digestCache;
        const buffer = this.buffer;
        if (this.hash === void 0) {
          const cacheKey = `${this.hashKey}-${encoding}`;
          digestCache = digestCaches[cacheKey];
          if (digestCache === void 0) {
            digestCache = digestCaches[cacheKey] = /* @__PURE__ */ new Map();
          }
          const cacheEntry = digestCache.get(buffer);
          if (cacheEntry !== void 0) return cacheEntry;
          this.hash = this.hashFactory();
        }
        if (buffer.length > 0) {
          this.hash.update(buffer);
        }
        const digestResult = this.hash.digest(encoding);
        const result = typeof digestResult === "string" ? digestResult : digestResult.toString();
        if (digestCache !== void 0) {
          digestCache.set(buffer, result);
        }
        return result;
      }
    };
    DebugHash = class extends Hash {
      constructor() {
        super();
        this.string = "";
      }
      /**
       * Update hash {@link https://nodejs.org/api/crypto.html#crypto_hash_update_data_inputencoding}
       * @param data data
       * @param _inputEncoding data encoding
       * @returns updated hash
       */
      update(data, _inputEncoding) {
        var _a;
        let normalizedData;
        if (typeof data !== "string") {
          normalizedData = data.toString("utf-8");
        } else {
          normalizedData = data;
        }
        if (normalizedData.startsWith("debug-digest-")) {
          normalizedData = Buffer.from(
            normalizedData.slice("debug-digest-".length),
            "hex"
          ).toString();
        }
        this.string += `[${normalizedData}](${(_a = new Error().stack) == null ? void 0 : _a.split("\n", 3)[2]})
`;
        return this;
      }
      /**
       * Calculates the digest {@link https://nodejs.org/api/crypto.html#crypto_hash_digest_encoding}
       * @param encoding encoding of the return value
       * @returns digest
       */
      digest(encoding) {
        return `debug-digest-${Buffer.from(this.string).toString(encoding || "hex")}`;
      }
    };
    createHash = (algorithm) => {
      if (typeof algorithm === "function") {
        return new BulkUpdateDecorator(() => new algorithm());
      }
      switch (algorithm) {
        // TODO add non-cryptographic algorithm here
        case "debug":
          return new DebugHash();
        case "xxhash64":
          return new BatchedHash(xxhash64_default());
        case "md4":
          return new BatchedHash(md4_default());
        case "native-md4":
          return new BulkUpdateDecorator(() => import_node_crypto.default.createHash("md4"), "md4");
        default:
          return new BulkUpdateDecorator(
            () => import_node_crypto.default.createHash(algorithm),
            algorithm
          );
      }
    };
  }
});

// src/util/cleverMerge.ts
var cleverMerge_exports = {};
__export(cleverMerge_exports, {
  DELETE: () => DELETE,
  cachedCleverMerge: () => cachedCleverMerge,
  cachedSetProperty: () => cachedSetProperty,
  cleverMerge: () => cleverMerge,
  removeOperations: () => removeOperations,
  resolveByProperty: () => resolveByProperty
});
function isPropertyInObject(obj, property) {
  return typeof obj === "object" && obj !== null && property in obj;
}
var DYNAMIC_INFO, mergeCache, setPropertyCache, DELETE, cachedCleverMerge, cachedSetProperty, parseCache, cachedParseObject, parseObject, serializeObject, VALUE_TYPE_UNDEFINED, VALUE_TYPE_ATOM, VALUE_TYPE_ARRAY_EXTEND, VALUE_TYPE_OBJECT, VALUE_TYPE_DELETE, getValueType, cleverMerge, _cleverMerge, mergeEntries, getFromByValues, mergeSingleValue, removeOperations, resolveByProperty;
var init_cleverMerge = __esm({
  "src/util/cleverMerge.ts"() {
    "use strict";
    DYNAMIC_INFO = Symbol("cleverMerge dynamic info");
    mergeCache = /* @__PURE__ */ new WeakMap();
    setPropertyCache = /* @__PURE__ */ new WeakMap();
    DELETE = Symbol("DELETE");
    cachedCleverMerge = (first, second) => {
      if (second === void 0) return first;
      if (first === void 0) return second;
      if (typeof second !== "object" || second === null) return second;
      if (typeof first !== "object" || first === null) return first;
      let innerCache = mergeCache.get(first);
      if (innerCache === void 0) {
        innerCache = /* @__PURE__ */ new WeakMap();
        mergeCache.set(first, innerCache);
      }
      const prevMerge = innerCache.get(second);
      if (prevMerge !== void 0) return prevMerge;
      const newMerge = _cleverMerge(first, second, true);
      innerCache.set(second, newMerge);
      return newMerge;
    };
    cachedSetProperty = (obj, property, value) => {
      let mapByProperty = setPropertyCache.get(obj);
      if (mapByProperty === void 0) {
        mapByProperty = /* @__PURE__ */ new Map();
        setPropertyCache.set(obj, mapByProperty);
      }
      let mapByValue = mapByProperty.get(property);
      if (mapByValue === void 0) {
        mapByValue = /* @__PURE__ */ new Map();
        mapByProperty.set(property, mapByValue);
      }
      let result = mapByValue.get(value);
      if (result) return result;
      result = {
        ...obj,
        [property]: value
      };
      mapByValue.set(value, result);
      return result;
    };
    parseCache = /* @__PURE__ */ new WeakMap();
    cachedParseObject = (obj) => {
      const entry = parseCache.get(obj);
      if (entry !== void 0) return entry;
      const result = parseObject(obj);
      parseCache.set(obj, result);
      return result;
    };
    parseObject = (obj) => {
      const info = /* @__PURE__ */ new Map();
      let dynamicInfo;
      const getInfo = (p) => {
        const entry = info.get(p);
        if (entry !== void 0) return entry;
        const newEntry = {
          base: void 0,
          byProperty: void 0,
          byValues: /* @__PURE__ */ new Map()
        };
        info.set(p, newEntry);
        return newEntry;
      };
      for (const key of Object.keys(obj)) {
        if (key.startsWith("by")) {
          const byProperty = key;
          const byObj = obj[byProperty];
          if (typeof byObj === "object") {
            for (const byValue of Object.keys(byObj)) {
              const obj2 = byObj[byValue];
              for (const key2 of Object.keys(obj2)) {
                const entry = getInfo(key2);
                if (entry.byProperty === void 0) {
                  entry.byProperty = byProperty;
                } else if (entry.byProperty !== byProperty) {
                  throw new Error(
                    `${byProperty} and ${entry.byProperty} for a single property is not supported`
                  );
                }
                entry.byValues.set(byValue, obj2[key2]);
                if (byValue === "default") {
                  for (const otherByValue of Object.keys(byObj)) {
                    if (!entry.byValues.has(otherByValue))
                      entry.byValues.set(otherByValue, void 0);
                  }
                }
              }
            }
          } else if (typeof byObj === "function") {
            if (dynamicInfo === void 0) {
              dynamicInfo = {
                byProperty: key,
                fn: byObj
              };
            } else {
              throw new Error(
                `${key} and ${dynamicInfo.byProperty} when both are functions is not supported`
              );
            }
          } else {
            const entry = getInfo(key);
            entry.base = obj[key];
          }
        } else {
          const entry = getInfo(key);
          entry.base = obj[key];
        }
      }
      return {
        static: info,
        dynamic: dynamicInfo
      };
    };
    serializeObject = (info, dynamicInfo) => {
      const obj = {};
      for (const entry of info.values()) {
        if (entry.byProperty !== void 0) {
          const byObj = obj[entry.byProperty] = obj[entry.byProperty] || {};
          for (const byValue of entry.byValues.keys()) {
            byObj[byValue] = byObj[byValue] || {};
          }
        }
      }
      for (const [key, entry] of info) {
        if (entry.base !== void 0) {
          obj[key] = entry.base;
        }
        if (entry.byProperty !== void 0) {
          const byObj = obj[entry.byProperty] = obj[entry.byProperty] || {};
          for (const byValue of Object.keys(byObj)) {
            const value = getFromByValues(entry.byValues, byValue);
            if (value !== void 0) byObj[byValue][key] = value;
          }
        }
      }
      if (dynamicInfo !== void 0) {
        obj[dynamicInfo.byProperty] = dynamicInfo.fn;
      }
      return obj;
    };
    VALUE_TYPE_UNDEFINED = 0;
    VALUE_TYPE_ATOM = 1;
    VALUE_TYPE_ARRAY_EXTEND = 2;
    VALUE_TYPE_OBJECT = 3;
    VALUE_TYPE_DELETE = 4;
    getValueType = (value) => {
      if (value === void 0) {
        return VALUE_TYPE_UNDEFINED;
      }
      if (value === DELETE) {
        return VALUE_TYPE_DELETE;
      }
      if (Array.isArray(value)) {
        if (value.lastIndexOf("...") !== -1) return VALUE_TYPE_ARRAY_EXTEND;
        return VALUE_TYPE_ATOM;
      }
      if (typeof value === "object" && value !== null && (!value.constructor || value.constructor === Object)) {
        return VALUE_TYPE_OBJECT;
      }
      return VALUE_TYPE_ATOM;
    };
    cleverMerge = (first, second) => {
      if (second === void 0) return first;
      if (first === void 0) return second;
      if (typeof second !== "object" || second === null) return second;
      if (typeof first !== "object" || first === null) return first;
      return _cleverMerge(first, second, false);
    };
    _cleverMerge = (first, second, internalCaching = false) => {
      const firstObject = internalCaching ? cachedParseObject(first) : parseObject(first);
      const { static: firstInfo, dynamic: firstDynamicInfo } = firstObject;
      let secondObj = second;
      if (firstDynamicInfo !== void 0) {
        let { byProperty, fn } = firstDynamicInfo;
        const fnInfo = fn[DYNAMIC_INFO];
        if (fnInfo) {
          secondObj = internalCaching ? cachedCleverMerge(fnInfo[1], second) : cleverMerge(fnInfo[1], second);
          fn = fnInfo[0];
        }
        const newFn = (...args) => {
          const fnResult = fn(...args);
          return internalCaching ? cachedCleverMerge(fnResult, secondObj) : cleverMerge(fnResult, secondObj);
        };
        newFn[DYNAMIC_INFO] = [fn, secondObj];
        return serializeObject(firstObject.static, { byProperty, fn: newFn });
      }
      const secondObject = internalCaching ? cachedParseObject(second) : parseObject(second);
      const { static: secondInfo, dynamic: secondDynamicInfo } = secondObject;
      const resultInfo = /* @__PURE__ */ new Map();
      for (const [key, firstEntry] of firstInfo) {
        const secondEntry = secondInfo.get(key);
        const entry = secondEntry !== void 0 ? mergeEntries(firstEntry, secondEntry, internalCaching) : firstEntry;
        resultInfo.set(key, entry);
      }
      for (const [key, secondEntry] of secondInfo) {
        if (!firstInfo.has(key)) {
          resultInfo.set(key, secondEntry);
        }
      }
      return serializeObject(resultInfo, secondDynamicInfo);
    };
    mergeEntries = (firstEntry, secondEntry, internalCaching) => {
      switch (getValueType(secondEntry.base)) {
        case VALUE_TYPE_ATOM:
        case VALUE_TYPE_DELETE:
          return secondEntry;
        case VALUE_TYPE_UNDEFINED: {
          if (!firstEntry.byProperty) {
            return {
              base: firstEntry.base,
              byProperty: secondEntry.byProperty,
              byValues: secondEntry.byValues
            };
          }
          if (firstEntry.byProperty !== secondEntry.byProperty) {
            throw new Error(
              `${firstEntry.byProperty} and ${secondEntry.byProperty} for a single property is not supported`
            );
          }
          const newByValues = new Map(firstEntry.byValues);
          for (const [key, value] of secondEntry.byValues) {
            const firstValue = getFromByValues(firstEntry.byValues, key);
            newByValues.set(
              key,
              mergeSingleValue(firstValue, value, internalCaching)
            );
          }
          return {
            base: firstEntry.base,
            byProperty: firstEntry.byProperty,
            byValues: newByValues
          };
        }
        default: {
          if (!firstEntry.byProperty) {
            return {
              base: mergeSingleValue(
                firstEntry.base,
                secondEntry.base,
                internalCaching
              ),
              byProperty: secondEntry.byProperty,
              byValues: secondEntry.byValues
            };
          }
          let newBase;
          const intermediateByValues = new Map(firstEntry.byValues);
          for (const [key, value] of intermediateByValues) {
            intermediateByValues.set(
              key,
              mergeSingleValue(value, secondEntry.base, internalCaching)
            );
          }
          if (Array.from(firstEntry.byValues.values()).every((value) => {
            const type = getValueType(value);
            return type === VALUE_TYPE_ATOM || type === VALUE_TYPE_DELETE;
          })) {
            newBase = mergeSingleValue(
              firstEntry.base,
              secondEntry.base,
              internalCaching
            );
          } else {
            newBase = firstEntry.base;
            if (!intermediateByValues.has("default"))
              intermediateByValues.set("default", secondEntry.base);
          }
          if (!secondEntry.byProperty) {
            return {
              base: newBase,
              byProperty: firstEntry.byProperty,
              byValues: intermediateByValues
            };
          }
          if (firstEntry.byProperty !== secondEntry.byProperty) {
            throw new Error(
              `${firstEntry.byProperty} and ${secondEntry.byProperty} for a single property is not supported`
            );
          }
          const newByValues = new Map(intermediateByValues);
          for (const [key, value] of secondEntry.byValues) {
            const firstValue = getFromByValues(intermediateByValues, key);
            newByValues.set(
              key,
              mergeSingleValue(firstValue, value, internalCaching)
            );
          }
          return {
            base: newBase,
            byProperty: firstEntry.byProperty,
            byValues: newByValues
          };
        }
      }
    };
    getFromByValues = (byValues, key) => {
      if (key !== "default" && byValues.has(key)) {
        return byValues.get(key);
      }
      return byValues.get("default");
    };
    mergeSingleValue = (a, b, internalCaching) => {
      const bType = getValueType(b);
      const aType = getValueType(a);
      switch (bType) {
        case VALUE_TYPE_DELETE:
        case VALUE_TYPE_ATOM:
          return b;
        case VALUE_TYPE_OBJECT: {
          return aType !== VALUE_TYPE_OBJECT ? b : internalCaching ? cachedCleverMerge(a, b) : cleverMerge(a, b);
        }
        case VALUE_TYPE_UNDEFINED:
          return a;
        case VALUE_TYPE_ARRAY_EXTEND:
          switch (aType !== VALUE_TYPE_ATOM ? aType : Array.isArray(a) ? VALUE_TYPE_ARRAY_EXTEND : VALUE_TYPE_OBJECT) {
            case VALUE_TYPE_UNDEFINED:
              return b;
            case VALUE_TYPE_DELETE:
              return b.filter((item) => item !== "...");
            case VALUE_TYPE_ARRAY_EXTEND: {
              const newArray = [];
              for (const item of b) {
                if (item === "...") {
                  for (const item2 of a) {
                    newArray.push(item2);
                  }
                } else {
                  newArray.push(item);
                }
              }
              return newArray;
            }
            case VALUE_TYPE_OBJECT:
              return b.map((item) => item === "..." ? a : item);
            default:
              throw new Error("Not implemented");
          }
        default:
          throw new Error("Not implemented");
      }
    };
    removeOperations = (obj) => {
      const newObj = {};
      for (const key of Object.keys(obj)) {
        const value = obj[key];
        const type = getValueType(value);
        switch (type) {
          case VALUE_TYPE_UNDEFINED:
          case VALUE_TYPE_DELETE:
            break;
          case VALUE_TYPE_OBJECT:
            newObj[key] = removeOperations(value);
            break;
          case VALUE_TYPE_ARRAY_EXTEND:
            newObj[key] = value.filter((i) => i !== "...");
            break;
          default:
            newObj[key] = value;
            break;
        }
      }
      return newObj;
    };
    resolveByProperty = (obj, byProperty, ...values) => {
      if (!isPropertyInObject(obj, byProperty)) {
        return obj;
      }
      const { [byProperty]: _byValue, ..._remaining } = obj;
      const remaining = _remaining;
      const byValue = _byValue;
      if (typeof byValue === "object") {
        const key = values[0];
        if (key in byValue) {
          return cachedCleverMerge(remaining, byValue[key]);
        }
        if ("default" in byValue) {
          return cachedCleverMerge(remaining, byValue.default);
        }
        return remaining;
      }
      if (typeof byValue === "function") {
        const result = byValue.apply(null, values);
        return cachedCleverMerge(
          remaining,
          resolveByProperty(result, byProperty, ...values)
        );
      }
    };
  }
});

// ../../node_modules/.pnpm/json-parse-even-better-errors@3.0.2/node_modules/json-parse-even-better-errors/lib/index.js
var require_lib = __commonJS({
  "../../node_modules/.pnpm/json-parse-even-better-errors@3.0.2/node_modules/json-parse-even-better-errors/lib/index.js"(exports2, module2) {
    "use strict";
    var INDENT = Symbol.for("indent");
    var NEWLINE = Symbol.for("newline");
    var DEFAULT_NEWLINE = "\n";
    var DEFAULT_INDENT = "  ";
    var BOM = /^\uFEFF/;
    var FORMAT = /^\s*[{[]((?:\r?\n)+)([\s\t]*)/;
    var EMPTY = /^(?:\{\}|\[\])((?:\r?\n)+)?$/;
    var UNEXPECTED_TOKEN = /^Unexpected token '?(.)'?(,)? /i;
    var hexify = (char) => {
      const h = char.charCodeAt(0).toString(16).toUpperCase();
      return `0x${h.length % 2 ? "0" : ""}${h}`;
    };
    var stripBOM = (txt) => String(txt).replace(BOM, "");
    var makeParsedError = (msg, parsing, position = 0) => ({
      message: `${msg} while parsing ${parsing}`,
      position
    });
    var parseError = (e, txt, context = 20) => {
      let msg = e.message;
      if (!txt) {
        return makeParsedError(msg, "empty string");
      }
      const badTokenMatch = msg.match(UNEXPECTED_TOKEN);
      const badIndexMatch = msg.match(/ position\s+(\d+)/i);
      if (badTokenMatch) {
        msg = msg.replace(
          UNEXPECTED_TOKEN,
          `Unexpected token ${JSON.stringify(badTokenMatch[1])} (${hexify(badTokenMatch[1])})$2 `
        );
      }
      let errIdx;
      if (badIndexMatch) {
        errIdx = +badIndexMatch[1];
      } else if (msg.match(/^Unexpected end of JSON.*/i)) {
        errIdx = txt.length - 1;
      }
      if (errIdx == null) {
        return makeParsedError(msg, `'${txt.slice(0, context * 2)}'`);
      }
      const start = errIdx <= context ? 0 : errIdx - context;
      const end = errIdx + context >= txt.length ? txt.length : errIdx + context;
      const slice = `${start ? "..." : ""}${txt.slice(start, end)}${end === txt.length ? "" : "..."}`;
      return makeParsedError(
        msg,
        `${txt === slice ? "" : "near "}${JSON.stringify(slice)}`,
        errIdx
      );
    };
    var JSONParseError = class extends SyntaxError {
      constructor(er, txt, context, caller) {
        const metadata = parseError(er, txt, context);
        super(metadata.message);
        Object.assign(this, metadata);
        this.code = "EJSONPARSE";
        this.systemError = er;
        Error.captureStackTrace(this, caller || this.constructor);
      }
      get name() {
        return this.constructor.name;
      }
      set name(n) {
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
    };
    var parseJson = (txt, reviver) => {
      const result = JSON.parse(txt, reviver);
      if (result && typeof result === "object") {
        const match = txt.match(EMPTY) || txt.match(FORMAT) || [null, "", ""];
        result[NEWLINE] = match[1] ?? DEFAULT_NEWLINE;
        result[INDENT] = match[2] ?? DEFAULT_INDENT;
      }
      return result;
    };
    var parseJsonError = (raw, reviver, context) => {
      const txt = stripBOM(raw);
      try {
        return parseJson(txt, reviver);
      } catch (e) {
        if (typeof raw !== "string" && !Buffer.isBuffer(raw)) {
          const msg = Array.isArray(raw) && raw.length === 0 ? "an empty array" : String(raw);
          throw Object.assign(
            new TypeError(`Cannot parse ${msg}`),
            { code: "EJSONPARSE", systemError: e }
          );
        }
        throw new JSONParseError(e, txt, context, parseJsonError);
      }
    };
    module2.exports = parseJsonError;
    parseJsonError.JSONParseError = JSONParseError;
    parseJsonError.noExceptions = (raw, reviver) => {
      try {
        return parseJson(stripBOM(raw), reviver);
      } catch {
      }
    };
  }
});

// src/loader-runner/worker.ts
var import_node_querystring = __toESM(require("querystring"));
var import_node_util3 = require("util");
var import_node_worker_threads2 = require("worker_threads");
var import_binding = require("@rspack/binding");
init_createHash();

// src/util/identifier.ts
var import_node_path = __toESM(require("path"));
var WINDOWS_ABS_PATH_REGEXP = /^[a-zA-Z]:[\\/]/;
var SEGMENTS_SPLIT_REGEXP = /([|!])/;
var WINDOWS_PATH_SEPARATOR_REGEXP = /\\/g;
var relativePathToRequest = (relativePath) => {
  if (relativePath === "") return "./.";
  if (relativePath === "..") return "../.";
  if (relativePath.startsWith("../")) return relativePath;
  return `./${relativePath}`;
};
var absoluteToRequest = (context, maybeAbsolutePath) => {
  if (maybeAbsolutePath[0] === "/") {
    if (maybeAbsolutePath.length > 1 && maybeAbsolutePath[maybeAbsolutePath.length - 1] === "/") {
      return maybeAbsolutePath;
    }
    const querySplitPos = maybeAbsolutePath.indexOf("?");
    let resource = querySplitPos === -1 ? maybeAbsolutePath : maybeAbsolutePath.slice(0, querySplitPos);
    resource = relativePathToRequest(import_node_path.default.posix.relative(context, resource));
    return querySplitPos === -1 ? resource : resource + maybeAbsolutePath.slice(querySplitPos);
  }
  if (WINDOWS_ABS_PATH_REGEXP.test(maybeAbsolutePath)) {
    const querySplitPos = maybeAbsolutePath.indexOf("?");
    let resource = querySplitPos === -1 ? maybeAbsolutePath : maybeAbsolutePath.slice(0, querySplitPos);
    resource = import_node_path.default.win32.relative(context, resource);
    if (!WINDOWS_ABS_PATH_REGEXP.test(resource)) {
      resource = relativePathToRequest(
        resource.replace(WINDOWS_PATH_SEPARATOR_REGEXP, "/")
      );
    }
    return querySplitPos === -1 ? resource : resource + maybeAbsolutePath.slice(querySplitPos);
  }
  return maybeAbsolutePath;
};
var requestToAbsolute = (context, relativePath) => {
  if (relativePath.startsWith("./") || relativePath.startsWith("../"))
    return import_node_path.default.join(context, relativePath);
  return relativePath;
};
var makeCacheable = (realFn) => {
  const cache = /* @__PURE__ */ new WeakMap();
  const getCache = (associatedObjectForCache) => {
    const entry = cache.get(associatedObjectForCache);
    if (entry !== void 0) return entry;
    const map = /* @__PURE__ */ new Map();
    cache.set(associatedObjectForCache, map);
    return map;
  };
  const fn = (str, associatedObjectForCache) => {
    if (!associatedObjectForCache) return realFn(str);
    const cache2 = getCache(associatedObjectForCache);
    const entry = cache2.get(str);
    if (entry !== void 0) return entry;
    const result = realFn(str);
    cache2.set(str, result);
    return result;
  };
  fn.bindCache = (associatedObjectForCache) => {
    const cache2 = getCache(associatedObjectForCache);
    return (str) => {
      const entry = cache2.get(str);
      if (entry !== void 0) return entry;
      const result = realFn(str);
      cache2.set(str, result);
      return result;
    };
  };
  return fn;
};
var makeCacheableWithContext = (fn) => {
  const cache = /* @__PURE__ */ new WeakMap();
  const cachedFn = (context, identifier, associatedObjectForCache) => {
    if (!associatedObjectForCache) return fn(context, identifier);
    let innerCache = cache.get(
      associatedObjectForCache
    );
    if (innerCache === void 0) {
      innerCache = /* @__PURE__ */ new Map();
      cache.set(associatedObjectForCache, innerCache);
    }
    let cachedResult;
    let innerSubCache = innerCache.get(context);
    if (innerSubCache === void 0) {
      innerCache.set(context, innerSubCache = /* @__PURE__ */ new Map());
    } else {
      cachedResult = innerSubCache.get(identifier);
    }
    if (cachedResult !== void 0) {
      return cachedResult;
    }
    const result = fn(context, identifier);
    innerSubCache.set(identifier, result);
    return result;
  };
  cachedFn.bindCache = (associatedObjectForCache) => {
    let innerCache;
    if (associatedObjectForCache) {
      innerCache = cache.get(associatedObjectForCache);
      if (innerCache === void 0) {
        innerCache = /* @__PURE__ */ new Map();
        cache.set(associatedObjectForCache, innerCache);
      }
    } else {
      innerCache = /* @__PURE__ */ new Map();
    }
    const boundFn = (context, identifier) => {
      let cachedResult;
      let innerSubCache = innerCache == null ? void 0 : innerCache.get(context);
      if (innerSubCache === void 0) {
        innerSubCache = /* @__PURE__ */ new Map();
        innerCache == null ? void 0 : innerCache.set(context, innerSubCache);
      } else {
        cachedResult = innerSubCache.get(identifier);
      }
      if (cachedResult !== void 0) {
        return cachedResult;
      }
      const result = fn(context, identifier);
      innerSubCache.set(identifier, result);
      return result;
    };
    return boundFn;
  };
  cachedFn.bindContextCache = (context, associatedObjectForCache) => {
    let innerSubCache;
    if (associatedObjectForCache) {
      let innerCache = cache.get(associatedObjectForCache);
      if (innerCache === void 0) {
        innerCache = /* @__PURE__ */ new Map();
        cache.set(associatedObjectForCache, innerCache);
      }
      innerSubCache = innerCache.get(context);
      if (innerSubCache === void 0) {
        innerCache.set(context, innerSubCache = /* @__PURE__ */ new Map());
      }
    } else {
      innerSubCache = /* @__PURE__ */ new Map();
    }
    const boundFn = (identifier) => {
      const cachedResult = innerSubCache == null ? void 0 : innerSubCache.get(identifier);
      if (cachedResult !== void 0) {
        return cachedResult;
      }
      const result = fn(context, identifier);
      innerSubCache == null ? void 0 : innerSubCache.set(identifier, result);
      return result;
    };
    return boundFn;
  };
  return cachedFn;
};
var _makePathsRelative = (context, identifier) => {
  return identifier.split(SEGMENTS_SPLIT_REGEXP).map((str) => absoluteToRequest(context, str)).join("");
};
var makePathsRelative = makeCacheableWithContext(_makePathsRelative);
var _makePathsAbsolute = (context, identifier) => {
  return identifier.split(SEGMENTS_SPLIT_REGEXP).map((str) => requestToAbsolute(context, str)).join("");
};
var makePathsAbsolute = makeCacheableWithContext(_makePathsAbsolute);
var _contextify = (context, request) => {
  return request.split("!").map((r) => absoluteToRequest(context, r)).join("!");
};
var contextify = makeCacheableWithContext(_contextify);
var _absolutify = (context, request) => {
  return request.split("!").map((r) => requestToAbsolute(context, r)).join("!");
};
var absolutify = makeCacheableWithContext(_absolutify);
var PATH_QUERY_FRAGMENT_REGEXP = /^((?:\u200b.|[^?#\u200b])*)(\?(?:\u200b.|[^#\u200b])*)?(#.*)?$/;
var PATH_QUERY_REGEXP = /^((?:\u200b.|[^?\u200b])*)(\?.*)?$/;
var _parseResource = (str) => {
  const match = PATH_QUERY_FRAGMENT_REGEXP.exec(str);
  return {
    resource: str,
    path: match[1].replace(/\u200b(.)/g, "$1"),
    query: match[2] ? match[2].replace(/\u200b(.)/g, "$1") : "",
    fragment: match[3] || ""
  };
};
var parseResource = makeCacheable(_parseResource);
var _parseResourceWithoutFragment = (str) => {
  const match = PATH_QUERY_REGEXP.exec(str);
  return {
    resource: str,
    path: match[1].replace(/\u200b(.)/g, "$1"),
    query: match[2] ? match[2].replace(/\u200b(.)/g, "$1") : ""
  };
};
var parseResourceWithoutFragment = makeCacheable(
  _parseResourceWithoutFragment
);

// src/util/memoize.ts
var memoize = (fn) => {
  let cache = false;
  let result;
  let callback = fn;
  return () => {
    if (cache) {
      return result;
    }
    result = callback();
    cache = true;
    callback = void 0;
    return result;
  };
};

// src/loader-runner/LoaderLoadingError.ts
var LoadingLoaderError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "LoaderRunnerError";
    Error.captureStackTrace(this, this.constructor);
  }
};
var LoaderLoadingError_default = LoadingLoaderError;

// src/loader-runner/loadLoader.ts
var url = void 0;
function loadLoader(loader, callback) {
  if (loader.type === "module") {
    try {
      if (url === void 0) url = require("url");
      const loaderUrl = url.pathToFileURL(loader.path);
      const modulePromise = import(loaderUrl.toString());
      modulePromise.then((module2) => {
        handleResult(loader, module2, callback);
      }, callback);
      return;
    } catch (e) {
      callback(e);
    }
  } else {
    let module2;
    try {
      module2 = require(loader.path);
    } catch (e) {
      if (e instanceof Error && e.code === "EMFILE") {
        const retry = loadLoader.bind(null, loader, callback);
        return void setImmediate(retry);
      }
      return callback(e);
    }
    return handleResult(loader, module2, callback);
  }
}
function handleResult(loader, module2, callback) {
  if (typeof module2 !== "function" && typeof module2 !== "object") {
    return callback(
      new LoaderLoadingError_default(
        `Module '${loader.path}' is not a loader (export function or es6 module)`
      )
    );
  }
  loader.normal = typeof module2 === "function" ? module2 : module2.default;
  loader.pitch = module2.pitch;
  loader.raw = module2.raw;
  if (typeof loader.normal !== "function" && typeof loader.pitch !== "function") {
    return callback(
      new LoaderLoadingError_default(
        `Module '${loader.path}' is not a loader (must have normal or pitch function)`
      )
    );
  }
  callback();
}

// src/loader-runner/service.ts
var import_node_path2 = __toESM(require("path"));
var import_node_worker_threads = require("worker_threads");
function isWorkerResponseMessage(message) {
  return message.type === "response";
}
function isWorkerResponseErrorMessage(message) {
  return message.type === "response-error";
}
function serializeError(error) {
  if (error instanceof Error || error && typeof error === "object" && "message" in error) {
    return {
      ...error,
      name: error.name,
      stack: error.stack,
      message: error.message
    };
  }
  if (typeof error === "string") {
    return {
      name: "Error",
      message: error
    };
  }
  throw new Error(
    "Failed to serialize error, only string, Error instances and objects with a message property are supported"
  );
}

// src/loader-runner/utils.ts
var import_node_util2 = require("util");
var decoder = new TextDecoder();
function utf8BufferToString(buf) {
  const str = decoder.decode(buf);
  if (str.charCodeAt(0) === 65279) {
    return str.slice(1);
  }
  return str;
}
function convertArgs(args, raw) {
  if (!raw && args[0] instanceof Uint8Array)
    args[0] = utf8BufferToString(args[0]);
  else if (raw && typeof args[0] === "string")
    args[0] = Buffer.from(args[0], "utf-8");
  if (raw && args[0] instanceof Uint8Array && !Buffer.isBuffer(args[0])) {
    args[0] = Buffer.from(args[0].buffer);
  }
}
var loadLoader2 = (0, import_node_util2.promisify)(loadLoader);
var runSyncOrAsync = (0, import_node_util2.promisify)(function runSyncOrAsync2(fn, context, args, callback) {
  let isSync = true;
  let isDone = false;
  let isError = false;
  let reportedError = false;
  context.async = function async() {
    if (isDone) {
      if (reportedError) return void 0;
      throw new Error("async(): The callback was already called.");
    }
    isSync = false;
    return innerCallback;
  };
  const innerCallback = (err, ...args2) => {
    if (isDone) {
      if (reportedError) return;
      throw new Error("callback(): The callback was already called.");
    }
    isDone = true;
    isSync = false;
    try {
      callback(err, args2);
    } catch (e) {
      isError = true;
      throw e;
    }
  };
  context.callback = innerCallback;
  try {
    const result = function LOADER_EXECUTION() {
      return fn.apply(context, args);
    }();
    if (isSync) {
      isDone = true;
      if (result === void 0) {
        callback(null, []);
        return;
      }
      if (result && typeof result === "object" && typeof result.then === "function") {
        result.then((r) => {
          callback(null, [r]);
        }, callback);
        return;
      }
      callback(null, [result]);
      return;
    }
  } catch (e) {
    const err = e;
    if ("hideStack" in err && err.hideStack) {
      err.hideStack = "true";
    }
    if (isError) throw e;
    if (isDone) {
      if (e instanceof Error) console.error(e.stack);
      else console.error(e);
      return;
    }
    isDone = true;
    reportedError = true;
    callback(e, []);
  }
});

// src/loader-runner/worker.ts
var BUILTIN_LOADER_PREFIX = "builtin:";
var loadLoaderAsync = (0, import_node_util3.promisify)(loadLoader);
function dirname(path3) {
  if (path3 === "/") return "/";
  const i = path3.lastIndexOf("/");
  const j = path3.lastIndexOf("\\");
  const i2 = path3.indexOf("/");
  const j2 = path3.indexOf("\\");
  const idx = i > j ? i : j;
  const idx2 = i > j ? i2 : j2;
  if (idx < 0) return path3;
  if (idx === idx2) return path3.slice(0, idx + 1);
  return path3.slice(0, idx);
}
async function loaderImpl({ args, loaderContext, loaderState }, sendRequest, waitForPendingRequest) {
  const resourcePath = loaderContext.resourcePath;
  const contextDirectory = resourcePath ? dirname(resourcePath) : null;
  const pendingDependencyRequest = [];
  loaderContext.parallel = true;
  loaderContext.dependency = loaderContext.addDependency = function addDependency(file) {
    pendingDependencyRequest.push(
      sendRequest("AddDependency" /* AddDependency */, file)
    );
  };
  loaderContext.addContextDependency = function addContextDependency(context) {
    pendingDependencyRequest.push(
      sendRequest("AddContextDependency" /* AddContextDependency */, context)
    );
  };
  loaderContext.addBuildDependency = function addBuildDependency(file) {
    pendingDependencyRequest.push(
      sendRequest("AddBuildDependency" /* AddBuildDependency */, file)
    );
  };
  loaderContext.getDependencies = function getDependencies() {
    waitForPendingRequest(pendingDependencyRequest);
    return sendRequest("GetDependencies" /* GetDependencies */).wait();
  };
  loaderContext.getContextDependencies = function getContextDependencies() {
    waitForPendingRequest(pendingDependencyRequest);
    return sendRequest("GetContextDependencies" /* GetContextDependencies */).wait();
  };
  loaderContext.getMissingDependencies = function getMissingDependencies() {
    waitForPendingRequest(pendingDependencyRequest);
    return sendRequest("GetMissingDependencies" /* GetMissingDependencies */).wait();
  };
  loaderContext.clearDependencies = function clearDependencies() {
    pendingDependencyRequest.push(sendRequest("ClearDependencies" /* ClearDependencies */));
  };
  loaderContext.importModule = function() {
    throw new Error("importModule is not supported in worker");
  };
  loaderContext.resolve = function resolve(context, request, callback) {
    sendRequest("Resolve" /* Resolve */, context, request).then(
      (result) => {
        callback(null, result);
      },
      (err) => {
        callback(err);
      }
    );
  };
  loaderContext.getResolve = function getResolve(options) {
    return (context, request, callback) => {
      if (!callback) {
        return new Promise((resolve, reject) => {
          sendRequest("GetResolve" /* GetResolve */, options, context, request).then(
            (result) => {
              resolve(result);
            },
            (err) => {
              reject(err);
            }
          );
        });
      }
      sendRequest("GetResolve" /* GetResolve */, options, context, request).then(
        (result) => {
          callback(null, result);
        },
        (err) => {
          callback(err);
        }
      );
    };
  };
  loaderContext.getLogger = function getLogger(name) {
    return {
      error(...args2) {
        sendRequest("GetLogger" /* GetLogger */, "error", name, args2);
      },
      warn(...args2) {
        sendRequest("GetLogger" /* GetLogger */, "warn", name, args2);
      },
      info(...args2) {
        sendRequest("GetLogger" /* GetLogger */, "info", name, args2);
      },
      log(...args2) {
        sendRequest("GetLogger" /* GetLogger */, "log", name, args2);
      },
      debug(...args2) {
        sendRequest("GetLogger" /* GetLogger */, "debug", name, args2);
      },
      assert(assertion, ...args2) {
        if (!assertion) {
          sendRequest("GetLogger" /* GetLogger */, "error", name, args2);
        }
      },
      trace() {
        sendRequest("GetLogger" /* GetLogger */, "trace", name, ["Trace"]);
      },
      clear() {
        sendRequest("GetLogger" /* GetLogger */, "clear", name);
      },
      status(...args2) {
        sendRequest("GetLogger" /* GetLogger */, "status", name, args2);
      },
      group(...args2) {
        sendRequest("GetLogger" /* GetLogger */, "group", name, args2);
      },
      groupCollapsed(...args2) {
        sendRequest("GetLogger" /* GetLogger */, "groupCollapsed", name, args2);
      },
      groupEnd(...args2) {
        sendRequest("GetLogger" /* GetLogger */, "groupEnd", name, args2);
      },
      profile(label) {
        sendRequest("GetLogger" /* GetLogger */, "profile", name, [label]);
      },
      profileEnd(label) {
        sendRequest("GetLogger" /* GetLogger */, "profileEnd", name, [label]);
      },
      time(label) {
        sendRequest("GetLogger" /* GetLogger */, "time", name, [label]);
      },
      timeEnd(label) {
        sendRequest("GetLogger" /* GetLogger */, "timeEnd", name, [label]);
      },
      timeLog(label, ...args2) {
        sendRequest("GetLogger" /* GetLogger */, "timeLog", name, [label, ...args2]);
      },
      timeAggregate(label) {
        sendRequest("GetLogger" /* GetLogger */, "timeAggregate", name, [label]);
      },
      timeAggregateEnd(label) {
        sendRequest("GetLogger" /* GetLogger */, "timeAggregateEnd", name, [label]);
      }
    };
  };
  loaderContext.emitError = function emitError(err) {
    sendRequest("EmitError" /* EmitError */, serializeError(err));
  };
  loaderContext.emitWarning = function emitWarning(warning) {
    sendRequest("EmitWarning" /* EmitWarning */, serializeError(warning));
  };
  loaderContext.emitFile = function emitFile(name, content, sourceMap, assetInfo) {
    sendRequest("EmitFile" /* EmitFile */, name, content, sourceMap, assetInfo);
  };
  loaderContext.experiments = {
    emitDiagnostic(diagnostic) {
      sendRequest("EmitDiagnostic" /* EmitDiagnostic */, diagnostic);
    }
  };
  const getAbsolutify = memoize(() => absolutify.bindCache({}));
  const getAbsolutifyInContext = memoize(
    () => absolutify.bindContextCache(contextDirectory, {})
  );
  const getContextify = memoize(() => contextify.bindCache({}));
  const getContextifyInContext = memoize(
    () => contextify.bindContextCache(contextDirectory, {})
  );
  loaderContext.utils = {
    absolutify: (context, request) => {
      return context === contextDirectory ? getAbsolutifyInContext()(request) : getAbsolutify()(context, request);
    },
    contextify: (context, request) => {
      return context === contextDirectory ? getContextifyInContext()(request) : getContextify()(context, request);
    },
    createHash: (type) => {
      return createHash(
        type || loaderContext._compilation.outputOptions.hashFunction
      );
    }
  };
  loaderContext._compiler = {
    ...loaderContext._compiler,
    // @ts-ignore
    webpack: {
      util: {
        createHash: (init_createHash(), __toCommonJS(createHash_exports)).createHash,
        cleverMerge: (init_cleverMerge(), __toCommonJS(cleverMerge_exports)).cleverMerge
      }
    }
  };
  const _module = loaderContext._module;
  loaderContext._module = {
    type: _module.type,
    identifier() {
      return _module.identifier;
    }
  };
  Object.defineProperty(loaderContext, "request", {
    enumerable: true,
    get: () => loaderContext.loaders.map((o) => o.request).concat(loaderContext.resource || "").join("!")
  });
  Object.defineProperty(loaderContext, "remainingRequest", {
    enumerable: true,
    get: () => {
      if (loaderContext.loaderIndex >= loaderContext.loaders.length - 1 && !loaderContext.resource)
        return "";
      return loaderContext.loaders.slice(loaderContext.loaderIndex + 1).map((o) => o.request).concat(loaderContext.resource || "").join("!");
    }
  });
  Object.defineProperty(loaderContext, "currentRequest", {
    enumerable: true,
    get: () => loaderContext.loaders.slice(loaderContext.loaderIndex).map((o) => o.request).concat(loaderContext.resource || "").join("!")
  });
  Object.defineProperty(loaderContext, "previousRequest", {
    enumerable: true,
    get: () => loaderContext.loaders.slice(0, loaderContext.loaderIndex).map((o) => o.request).join("!")
  });
  Object.defineProperty(loaderContext, "query", {
    enumerable: true,
    get: () => {
      const entry = loaderContext.loaders[loaderContext.loaderIndex];
      return entry.options && typeof entry.options === "object" ? entry.options : entry.query;
    }
  });
  loaderContext.getOptions = function getOptions() {
    const loader = getCurrentLoader(loaderContext);
    let options = loader == null ? void 0 : loader.options;
    if (typeof options === "string") {
      if (options.startsWith("{") && options.endsWith("}")) {
        try {
          const parseJson = require_lib();
          options = parseJson(options);
        } catch (e) {
          throw new Error(`Cannot parse string options: ${e.message}`);
        }
      } else {
        options = import_node_querystring.default.parse(options);
      }
    }
    if (options === null || options === void 0) {
      options = {};
    }
    return options;
  };
  loaderContext.cacheable = function cacheable(flag) {
    if (flag === false) {
      sendRequest("SetCacheable" /* SetCacheable */, false);
    }
  };
  Object.defineProperty(loaderContext, "data", {
    enumerable: true,
    get: () => loaderContext.loaders[loaderContext.loaderIndex].loaderItem.data,
    set: (value) => {
      loaderContext.loaders[loaderContext.loaderIndex].loaderItem.data = value;
    }
  });
  const shouldYieldToMainThread = (currentLoaderObject) => {
    if (!(currentLoaderObject == null ? void 0 : currentLoaderObject.parallel)) {
      return true;
    }
    if (currentLoaderObject == null ? void 0 : currentLoaderObject.request.startsWith(BUILTIN_LOADER_PREFIX)) {
      return true;
    }
    return false;
  };
  switch (loaderState) {
    case import_binding.JsLoaderState.Pitching: {
      while (loaderContext.loaderIndex < loaderContext.loaders.length) {
        const currentLoaderObject = loaderContext.loaders[loaderContext.loaderIndex];
        if (shouldYieldToMainThread(currentLoaderObject)) break;
        if (currentLoaderObject.pitchExecuted) {
          loaderContext.loaderIndex += 1;
          continue;
        }
        await loadLoaderAsync(currentLoaderObject);
        const fn = currentLoaderObject.pitch;
        currentLoaderObject.pitchExecuted = true;
        if (!fn) continue;
        args = await runSyncOrAsync(fn, loaderContext, [
          loaderContext.remainingRequest,
          loaderContext.previousRequest,
          currentLoaderObject.loaderItem.data
        ]) || [];
        const hasArg = args.some((value) => value !== void 0);
        if (hasArg) {
          break;
        }
      }
    }
    case import_binding.JsLoaderState.Normal: {
      while (loaderContext.loaderIndex >= 0) {
        const currentLoaderObject = loaderContext.loaders[loaderContext.loaderIndex];
        if (shouldYieldToMainThread(currentLoaderObject)) break;
        if (currentLoaderObject.normalExecuted) {
          loaderContext.loaderIndex--;
          continue;
        }
        await loadLoaderAsync(currentLoaderObject);
        const fn = currentLoaderObject.normal;
        currentLoaderObject.normalExecuted = true;
        if (!fn) continue;
        convertArgs(args, !!currentLoaderObject.raw);
        args = await runSyncOrAsync(fn, loaderContext, args) || [];
      }
    }
  }
  sendRequest(
    "UpdateLoaderObjects" /* UpdateLoaderObjects */,
    loaderContext.loaders.map((item) => {
      return {
        data: item.loaderItem.data,
        normalExecuted: item.normalExecuted,
        pitchExecuted: item.pitchExecuted
      };
    })
  );
  return args;
}
var nextId = 0;
var responseCallbacks = {};
function handleIncomingResponses(workerMessage) {
  if (isWorkerResponseMessage(workerMessage)) {
    const { id, data } = workerMessage;
    const callback = responseCallbacks[id];
    if (callback) {
      delete responseCallbacks[id];
      callback(
        null,
        /* data */
        data
      );
    } else {
      throw new Error(`No callback found for response with id ${id}`);
    }
  } else if (isWorkerResponseErrorMessage(workerMessage)) {
    const { id, error } = workerMessage;
    const callback = responseCallbacks[id];
    if (callback) {
      delete responseCallbacks[id];
      callback(error, void 0);
    } else {
      throw new Error(`No callback found for response with id ${id}`);
    }
  }
}
function createWaitForPendingRequest(sendRequest) {
  return (requests) => {
    return sendRequest.sync(
      "WaitForPendingRequest" /* WaitForPendingRequest */,
      (Array.isArray(requests) ? requests : [requests]).map((request) => {
        return request.id;
      })
    );
  };
}
function createSendRequest(workerPort, workerSyncPort) {
  const sendRequest = (requestType, ...args) => {
    const id = nextId++;
    workerPort.postMessage({
      type: "request",
      id,
      requestType,
      data: args
    });
    const result = new Promise((resolve, reject) => {
      responseCallbacks[id] = (err, data) => {
        if (err) {
          reject(err);
          return;
        }
        resolve(data);
      };
    });
    result.wait = () => {
      return sendRequest.sync("WaitForPendingRequest" /* WaitForPendingRequest */, id);
    };
    result.id = id;
    return result;
  };
  sendRequest.sync = createSendRequestSync(workerSyncPort);
  return sendRequest;
}
function createSendRequestSync(workerSyncPort) {
  return (requestType, ...args) => {
    const id = nextId++;
    const sharedBuffer = new SharedArrayBuffer(8);
    const sharedBufferView = new Int32Array(sharedBuffer);
    workerSyncPort.postMessage({
      type: "request-sync",
      id,
      requestType,
      data: args,
      sharedBuffer
    });
    const status = Atomics.wait(sharedBufferView, 0, 0);
    if (status !== "ok" && status !== "not-equal")
      throw new Error(`Internal error: Atomics.wait() failed: ${status}`);
    const {
      message
    } = (0, import_node_worker_threads2.receiveMessageOnPort)(workerSyncPort);
    if (id !== message.id) {
      throw new Error(`Unexpected response id: ${message.id}, expected: ${id}`);
    }
    if (isWorkerResponseMessage(message)) {
      return message.data;
    }
    throw message.error;
  };
}
function worker(workerOptions) {
  const workerData = workerOptions.workerData;
  delete workerOptions.workerData;
  workerData.workerPort.on("message", handleIncomingResponses);
  const sendRequest = createSendRequest(
    workerData.workerPort,
    workerData.workerSyncPort
  );
  const waitFor = createWaitForPendingRequest(sendRequest);
  loaderImpl(workerOptions, sendRequest, waitFor).then(async (data) => {
    workerData.workerPort.postMessage({ type: "done", data });
  }).catch(async (err) => {
    workerData.workerPort.postMessage({
      type: "done-error",
      error: serializeError(err)
    });
  });
}
function getCurrentLoader(loaderContext, index = loaderContext.loaderIndex) {
  var _a;
  if (((_a = loaderContext.loaders) == null ? void 0 : _a.length) && index < loaderContext.loaders.length && index >= 0 && loaderContext.loaders[index]) {
    return loaderContext.loaders[index];
  }
  return null;
}
module.exports = worker;
